vue3初探
模板中的内容一定要是响应式的才行
setup: setup意为准备，它会在所有生命周期前，因此它内部不能访问this
ref: 将对象变成响应式的，响应式对象的值存在value中
computed: 同vue2的计算属性，使用他要将计算过程放在回调中
reactive: 将同一段逻辑中所用到的数据、方法组合在一起
访问reactive中的变量时不需要.value(reactive中的项并不具有响应性)
toRefs: 将对象中的值全部变成响应式的(配合reactive使用)

vue2使用defineProperty实现对象的响应性(缺点: this.arr[0] = 1和this.obj.name = '123'
之类的操作无法监听到)
vue3使用proxy来实现对象的响应性，弥补了vue2的缺点

生命周期
vue3的生命周期与vue2的大体相同，在vue2的生命周期前加上on就可
没有beforeCreate和created，它们被放在了setup
onRenderTracked和onRenderTriggered被用作调试

watch
vue3的watch写在setup中，它是一个回调函数，接受的参数分别是要监听的值、变化后的值、变化前的值
watch(sum,(newVal,oldVal)=> {console.log(newVal，oldVal)})
想要一次监听多个值，可以使用数组的形式，此时返回的值也是数组形式
watch([number1,number2],(newVal,oldVal)=> {console.log(newVal，oldVal)})
此时的newVal和oldVal都是多个值的数组，监听reactive包裹对象中的值: ()=>{data.count}

hooks
vue3中的hooks是指将一段逻辑及其它用到的数据、方法全部提取出来，做成一个函数，以模块的方式分离
和提取，这样让逻辑清晰分明

泛型改造
ref也可以使用泛型，这里的泛型表示的是ref的value的类型

defineComponent
使用defineComponent包裹组件，让组件具有ts的支持
setup(props,context)
setup的两个参数props和context，props可以访问这个组件所有传入的prop
context具有三个参数: attr(属性),slots(插槽),emit(发送)

teleport
意为传送门，使用teleport包裹组件，并添加to属性，将包裹的组件传送到to的组件内


